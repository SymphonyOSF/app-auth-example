/*
 * Copyright 2016-2017 Symphony Application Authentication - Symphony LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.symphony.example.authentication;

import com.symphony.example.users.User;
import com.symphony.example.users.UserNotFoundException;
import com.symphony.example.users.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.security.auth.login.LoginException;

import static org.springframework.web.bind.annotation.RequestMethod.POST;

/**
 * Authentication controller.  These methods are called by the integrated app's front end which is displayed in an
 * iFrame in the Symphony Client.  The endpoints' URLs and implementation details are up to the integration partners
 * discretion.
 *
 * @author Dan Nathanson
 */
@RestController
public class AuthenticationController {

    private final AuthenticationService authenticationService;
    private final UserService userService;

    @Autowired
    public AuthenticationController(AuthenticationService authenticationService, UserService userService) {
        this.authenticationService = authenticationService;
        this.userService = userService;
    }

    /**
     * Start the app authentication flow.  At this point, only the pod ID is known (which was provided to the
     * app by the Symphony Client Extension API).  Company ID is just a unique string/number and identifies the
     * pod. AuthenticationService will exchange tokens with Symphony back end.  The token
     * from generated by this app is returned from this endpoint.
     *
     * @return App token
     */
    @RequestMapping(method = POST, path = "/authenticate", produces = "application/json")
    public HttpEntity<String> authenticate(@RequestBody String companyId) {
        return new HttpEntity<>('"' + authenticationService.initiateAppAuthentication(companyId) + '"');
    }


    /**
     * Validate token pair.  This implementation assumes statelessness on the server side so both tokens are required
     * in the request.  If this application supported sticky sessions, only the Symphony token would be required
     * since the application token could have been saved in session state.
     *
     * @param request object containing both authentication tokens
     * @return "Valid" (and HTTP 200) or "Invalid" (and HTTP 401)
     */
    @RequestMapping(method = POST, path = "/validate-tokens")
    public ResponseEntity<String> validateTokens(@RequestBody ValidateTokensRequest request) {
        if (authenticationService.validateTokens(request.getAppToken(), request.getSymphonyToken())) {
            return new ResponseEntity<>("\"Valid\"", HttpStatus.OK);
        }
        else {
            return new ResponseEntity<>("\"Invalid\"", HttpStatus.UNAUTHORIZED);
        }
    }

    /**
     * Login using JWT.  If JWT is valid, tries to correlate Symphony username from JWT with a User in this
     * application.  If the user cannot be found using username, return response code that can be used by app
     * to prompt user for credentials on this application.  App will then display a form to collect username for
     * this application and submit it back along with JWT so that correlation between Symphony user and this
     * application user can be recorded.
     * @param request request object, includes JWT and pod ID.
     * @return HTTP 200 - JWT valid. Response body will contain indication of whether username was matched to an
     *                    application user<br/>
     *         HTTP 400 - JWT missing<br/>
     *         HTTP 401 - JWT can't be parsed or can't be validated
     */
    @RequestMapping(method = POST, path = "/login-with-jwt")
    public ResponseEntity<LoginResponse> login(@RequestBody JwtLoginRequest request) {
        LoginResponse response = new LoginResponse();
        HttpStatus status = HttpStatus.OK;

        if (StringUtils.isEmpty(request.getJwt()) || StringUtils.isEmpty(request.getCompanyId())) {
            response.setMessage("Missing JWT or pod ID in request");
            status = HttpStatus.BAD_REQUEST;
        }
        else {
            try {
                String symphonyUsername = authenticationService.getUserFromJwt(request.getJwt(), request.getCompanyId());
                response.setJwtValid(true);
                User user = userService.findBySymphonyId(symphonyUsername);
                if (user == null) {
                    response.setMessage("Could not find user corresponding to Symphony username from JWT");
                }
                else {
                    response.setMessage("Hello " + user.getDisplayName());
                    response.setUserDisplayName(user.getDisplayName());
                    response.setUserFound(true);
                }
            } catch (LoginException e) {
                response.setMessage("Could not parse or verify signature of JWT");
                status = HttpStatus.UNAUTHORIZED;
            }
        }

        return new ResponseEntity<>(response, status);
    }
    
    /**
     * Login using username.  Since this is a demo app, only username is required to log in.  In a real application
     * real authentication (like username/password or SSO) would be used.  Both username and JWT + pod ID are part of 
     * the request to allow statelessness.  An alternative using sessions could allow the JWT to be removed from the 
     * request and stored in the session.  If the call to this endpoint succeeds, the correlation between the two
     * applications is recorded in the User object and this endpoint doesn't need to be called again for the same user.
     * 
     * @param request request object, includes username, JWT and pod ID.
     * @return HTTP 200 - User found for provided username and JWT valid<br/>
     *         HTTP 400 - username or JWT+pod ID missing<br/>
     *         HTTP 401 - User not found with provided username or JWT can't be parsed and validated
     */
    @RequestMapping(method = POST, path = "/login-with-username")
    public ResponseEntity<LoginResponse> loginWithUsername(@RequestBody UsernameLoginRequest request) {
        LoginResponse response = new LoginResponse();
        HttpStatus status = HttpStatus.OK;

        if (StringUtils.isEmpty(request.getJwt()) || StringUtils.isEmpty(request.getCompanyId()) || StringUtils.isEmpty(request.getUsername())) {
            response.setMessage("Missing username, JWT or pod ID in request");
            status = HttpStatus.BAD_REQUEST;
        }
        else {
            try {
                User user = userService.get(request.getUsername());
                String symphonyUsername = authenticationService.getUserFromJwt(request.getJwt(), request.getCompanyId());

                // Save Symphony username in user record to record mapping
                user.setSymphonyId(symphonyUsername);

                response.setJwtValid(true);
                response.setUserFound(true);
                response.setMessage("Hello " + user.getDisplayName());
                response.setUserDisplayName(user.getDisplayName());

            } catch (UserNotFoundException e) {
                response.setMessage("Could not find user with username '" + request.getUsername() + "'");
                response.setUserFound(false);
                status = HttpStatus.UNAUTHORIZED;
            } catch (LoginException e) {
                response.setMessage("Could not parse or verify signature of JWT");
                status = HttpStatus.UNAUTHORIZED;
            }
        }

        return new ResponseEntity<>(response, status);
    }
    
    
}
